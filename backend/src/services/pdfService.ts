import PDFDocument from 'pdfkit';

interface QuiltPattern {
  patternName: string;
  description: string;
  fabricLayout: string;
  difficulty: string;
  estimatedSize: string;
  instructions: string[];
  visualSvg: string;
}

export class PDFService {
  async generatePatternPDF(pattern: QuiltPattern, userName: string): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        // Create PDF document
        const doc = new PDFDocument({
          size: 'LETTER',
          margins: { top: 50, bottom: 50, left: 50, right: 50 }
        });

        // Collect PDF chunks
        const chunks: Buffer[] = [];
        doc.on('data', (chunk) => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));
        doc.on('error', reject);

        // Header
        doc.fontSize(24)
           .font('Helvetica-Bold')
           .fillColor('#4F46E5')
           .text('QuiltPlannerPro', { align: 'center' })
           .moveDown(0.5);

        // Pattern Name
        doc.fontSize(20)
           .fillColor('#111827')
           .text(pattern.patternName, { align: 'center' })
           .moveDown(1);

        // Metadata Box
        doc.fontSize(10)
           .fillColor('#6B7280')
           .font('Helvetica');

        const metadataY = doc.y;
        doc.rect(50, metadataY, 495, 60)
           .stroke('#E5E7EB');

        doc.fontSize(10)
           .fillColor('#374151')
           .text(`Difficulty: ${pattern.difficulty}`, 60, metadataY + 10)
           .text(`Size: ${pattern.estimatedSize}`, 60, metadataY + 25)
           .text(`Created for: ${userName}`, 60, metadataY + 40);

        doc.moveDown(2);

        // Pattern Visualization Section
        if (pattern.visualSvg && pattern.visualSvg.includes('svg')) {
          doc.fontSize(14)
             .font('Helvetica-Bold')
             .fillColor('#111827')
             .text('Pattern Visualization')
             .moveDown(0.5);

          try {
            this.drawSVGPattern(doc, pattern.visualSvg);
            doc.moveDown(1.5);
          } catch (err) {
            console.error('Error drawing SVG:', err);
            doc.fontSize(10)
               .font('Helvetica')
               .fillColor('#6B7280')
               .text('(Pattern visualization available in web app)', { align: 'center' })
               .moveDown(1);
          }
        }

        // Description Section
        doc.fontSize(14)
           .fillColor('#111827')
           .font('Helvetica-Bold')
           .text('Pattern Description')
           .moveDown(0.5);

        doc.fontSize(10)
           .font('Helvetica')
           .fillColor('#374151')
           .text(pattern.description, { align: 'justify' })
           .moveDown(1);

        // Fabric Layout Section
        doc.fontSize(14)
           .font('Helvetica-Bold')
           .fillColor('#111827')
           .text('Fabric Layout')
           .moveDown(0.5);

        doc.fontSize(10)
           .font('Helvetica')
           .fillColor('#374151')
           .text(pattern.fabricLayout, { align: 'justify' })
           .moveDown(1.5);

        // Instructions Section
        doc.fontSize(14)
           .font('Helvetica-Bold')
           .fillColor('#111827')
           .text('Step-by-Step Instructions')
           .moveDown(0.5);

        doc.fontSize(10)
           .font('Helvetica')
           .fillColor('#374151');

        pattern.instructions.forEach((instruction, index) => {
          const stepNumber = `${index + 1}.`;
          
          // Check if we need a new page
          if (doc.y > 700) {
            doc.addPage();
          }

          doc.font('Helvetica-Bold')
             .text(stepNumber, { continued: true })
             .font('Helvetica')
             .text(` ${instruction}`, { align: 'justify' })
             .moveDown(0.5);
        });

        // Footer
        const pageCount = doc.bufferedPageRange().count;
        for (let i = 0; i < pageCount; i++) {
          doc.switchToPage(i);
          doc.fontSize(8)
             .fillColor('#9CA3AF')
             .text(
               `Generated by QuiltPlannerPro on ${new Date().toLocaleDateString()} | Page ${i + 1} of ${pageCount}`,
               50,
               750,
               { align: 'center', width: 495 }
             );
        }

        // Finalize PDF
        doc.end();

      } catch (error) {
        reject(error);
      }
    });
  }

  private drawSVGPattern(doc: InstanceType<typeof PDFDocument>, svgString: string): void {
    // Extract rect elements from SVG
    const rectMatches = svgString.matchAll(/<rect[^>]+>/g);
    
    const startX = 200; // Center offset
    const startY = doc.y;
    const scale = 0.8;

    for (const match of rectMatches) {
      const rect = match[0];
      
      const xMatch = rect.match(/x=['"]([^'"]+)['"]/);
      const yMatch = rect.match(/y=['"]([^'"]+)['"]/);
      const widthMatch = rect.match(/width=['"]([^'"]+)['"]/);
      const heightMatch = rect.match(/height=['"]([^'"]+)['"]/);
      const fillMatch = rect.match(/fill=['"]([^'"]+)['"]/);

      if (xMatch && yMatch && widthMatch && heightMatch && fillMatch) {
        const x = parseFloat(xMatch[1]) * scale + startX;
        const y = parseFloat(yMatch[1]) * scale + startY;
        const width = parseFloat(widthMatch[1]) * scale;
        const height = parseFloat(heightMatch[1]) * scale;
        const fill = fillMatch[1];

        doc.rect(x, y, width, height)
           .fillAndStroke(fill, '#000000');
      }
    }

    // Move cursor past visualization
    doc.y = startY + 320;
  }
}
