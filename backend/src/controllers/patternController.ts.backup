import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { ClaudeService } from '../services/claudeService';
import { SUBSCRIPTION_TIERS } from '../config/stripe.config';
import { PDFService } from '../services/pdfService';
import { getAllPatterns } from '../config/patterns';
import { getQuiltPattern } from '../config/quiltPatterns';
import { generateInstructions } from '../services/instructions/generateInstructions';
import { parseQuiltSizeIn } from '../utils/parseQuiltSize';
import { normalizePatternId, resolvePatternIdForDeterministic } from '../utils/patternNormalization';
import { buildFabricsByRole, convertToFabricAssignments } from '../utils/fabricMapping';

const prisma = new PrismaClient();

export class PatternController {
  private claudeService: ClaudeService;

  constructor() {
    this.claudeService = new ClaudeService();
  }

  // POST /api/patterns/generate
  async generatePattern(req: Request, res: Response) {
    try {
      const userId = req.user?.userId;

      if (!userId) {
        return res.status(401).json({
          success: false,
          message: 'Unauthorized',
        });
      }

      const { fabricImages, fabrics, fabricTypes, skillLevel, challengeMe, selectedPattern, roleAssignments } =
        req.body;
      const images = fabricImages || fabrics;
      const imageTypes = fabricTypes || [];

      console.log('ðŸ“¸ Received image types:', imageTypes);
      console.log('ðŸ“¸ Images count:', images?.length, 'Types count:', imageTypes.length);
      console.log('ðŸ“‹ Raw selectedPattern from frontend:', selectedPattern);

      // âœ… UPDATED: allow up to 9 images
      if (!images || !Array.isArray(images) || images.length < 2 || images.length > 9) {
        return res.status(400).json({
          success: false,
          message: 'Please provide 2-9 fabric images',
        });
      }

      // Validate image sizes (5MB per image in base64)
      const MAX_IMAGE_SIZE = 5 * 1024 * 1024; // 5MB
      for (let i = 0; i < images.length; i++) {
        const base64Data = images[i].replace(/^data:image\/\w+;base64,/, '');
        const sizeInBytes = (base64Data.length * 3) / 4;
        if (sizeInBytes > MAX_IMAGE_SIZE) {
          return res.status(400).json({
            success: false,
            message: `Image ${i + 1} exceeds 5MB limit`,
          });
        }
      }

      const validSkillLevels = ['beginner', 'advanced_beginner', 'intermediate', 'advanced', 'expert'];
      if (skillLevel && !validSkillLevels.includes(skillLevel)) {
        return res.status(400).json({
          success: false,
          message: 'Invalid skill level',
        });
      }

      const patternToUse = normalizePatternId(selectedPattern);
      console.log(`ðŸ“‹ Pattern to use: "${patternToUse}" (from: "${selectedPattern}")`);

      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: {
          id: true,
          email: true,
          name: true,
          skillLevel: true,
          subscriptionTier: true,
          subscriptionStatus: true,
          currentPeriodEnd: true,
          generationsThisMonth: true,
        },
      });

      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'User not found',
        });
      }

      if (
        user.subscriptionStatus === 'canceled' ||
        (user.currentPeriodEnd && new Date(user.currentPeriodEnd) < new Date())
      ) {
        return res.status(403).json({
          success: false,
          message: 'Your subscription has expired. Please renew to generate patterns.',
        });
      }

      const tierConfig = SUBSCRIPTION_TIERS[user.subscriptionTier as keyof typeof SUBSCRIPTION_TIERS];

      if (user.generationsThisMonth >= tierConfig.generationsPerMonth) {
        return res.status(403).json({
          success: false,
          message: `You've reached your monthly limit of ${tierConfig.generationsPerMonth} pattern generations. Upgrade your plan for more!`,
          currentUsage: user.generationsThisMonth,
          limit: tierConfig.generationsPerMonth,
        });
      }

      let targetSkillLevel = skillLevel || user.skillLevel || 'beginner';

      if (challengeMe) {
        const skillProgression = ['beginner', 'advanced_beginner', 'intermediate', 'advanced', 'expert'];
        const currentIndex = skillProgression.indexOf(targetSkillLevel);
        if (currentIndex < skillProgression.length - 1) {
          targetSkillLevel = skillProgression[currentIndex + 1];
        }
      }

      // Claude generates visual/design + metadata
      const pattern: any = await this.claudeService.generateQuiltPattern(
        images,
        imageTypes,
        targetSkillLevel,
        patternToUse,
        roleAssignments
      );

      // âœ… MVP: overwrite instructions with deterministic when supported
      const resolvedPatternId = resolvePatternIdForDeterministic(patternToUse, pattern);
      const fabricsByRole = buildFabricsByRole(roleAssignments, pattern);

      pattern.patternId = resolvedPatternId;
      pattern.fabricsByRole = fabricsByRole;

      try {
        const quiltSize = parseQuiltSizeIn(pattern.estimatedSize);
        const fabricAssignments = convertToFabricAssignments(fabricsByRole);
        const det = generateInstructions(
          resolvedPatternId,
          { widthIn: quiltSize.width, heightIn: quiltSize.height },
          fabricAssignments
        );

        if (det.kind === 'generated') {
          pattern.instructions = det.instructions;
          pattern.instructionsSource = 'deterministic';
          console.log(
            `[INSTRUCTIONS] Deterministic used patternId="${resolvedPatternId}" steps=${det.instructions.length}`
          );
        } else {
          pattern.instructionsSource = 'llm';
          console.warn(`[INSTRUCTIONS] Deterministic not supported patternId="${resolvedPatternId}"`);
        }
      } catch (e) {
        pattern.instructionsSource = 'llm';
        console.warn(
          `[INSTRUCTIONS] Deterministic generation failed patternId="${resolvedPatternId}". Using LLM instructions.`,
          e
        );
      }

      const savedPattern = await prisma.$transaction(async (tx) => {
        const newPattern = await tx.pattern.create({
          data: {
            userId: user.id,
            patternData: pattern as any,
            downloaded: false,
          },
        });

        await tx.user.update({
          where: { id: userId },
          data: {
            generationsThisMonth: { increment: 1 },
          },
        });

        return newPattern;
      });

      const remainingGenerations = tierConfig.generationsPerMonth - (user.generationsThisMonth + 1);

      console.log('Pattern structure:', {
        patternId: resolvedPatternId,
        instructionsSource: pattern.instructionsSource,
        hasInstructions: !!pattern.instructions,
        instructionsLength: pattern.instructions?.length,
        instructionsComplete: pattern.instructions?.every((i: string) => i.length > 10),
      });

      res.status(200).json({
        success: true,
        data: {
          pattern: {
            ...pattern,
            id: savedPattern.id,
          },
          usage: {
            used: user.generationsThisMonth + 1,
            limit: tierConfig.generationsPerMonth,
            remaining: remainingGenerations,
          },
        },
      });
    } catch (error) {
      console.error('Pattern generation error:', error);

      let message = 'Failed to generate quilt pattern. Please try again.';
      if (error instanceof Error) {
        if (error.message.includes('high demand') || error.message.includes('experiencing')) {
          message = error.message;
        } else if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {
          message = 'Pattern generation timed out. Please try again with fewer images.';
        } else if (error.message.includes('rate limit')) {
          message = 'Service is busy. Please wait a moment and try again.';
        }
      }

      res.status(500).json({
        success: false,
        message,
      });
    }
  }

  // GET /api/patterns/:id/download
  async downloadPattern(req: Request, res: Response) {
    try {
      const { id: patternId } = req.params;
      const userId = req.user?.userId;

      if (!userId) {
        return res.status(401).json({
          success: false,
          message: 'Unauthorized',
        });
      }

      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: {
          id: true,
          name: true,
          email: true,
          subscriptionTier: true,
          subscriptionStatus: true,
          currentPeriodEnd: true,
          downloadsThisMonth: true,
        },
      });

      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'User not found',
        });
      }

      if (
        user.subscriptionStatus === 'canceled' ||
        (user.currentPeriodEnd && new Date(user.currentPeriodEnd) < new Date())
      ) {
        return res.status(403).json({
          success: false,
          message: 'Your subscription has expired. Please renew to download patterns.',
        });
      }

      const pattern = await prisma.pattern.findFirst({
        where: {
          id: patternId,
          userId: userId,
        },
      });

      if (!pattern) {
        return res.status(404).json({
          success: false,
          message: 'Pattern not found or you do not have permission to download it',
        });
      }

      const isFirstDownload = !pattern.downloaded;

      if (isFirstDownload) {
        const tierConfig = SUBSCRIPTION_TIERS[user.subscriptionTier as keyof typeof SUBSCRIPTION_TIERS];

        if (user.downloadsThisMonth >= tierConfig.downloadsPerMonth) {
          return res.status(403).json({
            success: false,
            message: `You've reached your monthly download limit of ${tierConfig.downloadsPerMonth}. Upgrade your plan for more downloads!`,
            currentUsage: user.downloadsThisMonth,
            limit: tierConfig.downloadsPerMonth,
          });
        }
      }

      const pdfService = new PDFService();
      const pdfBuffer = await pdfService.generatePatternPDF(pattern.patternData as any, user.name || user.email);

      if (isFirstDownload) {
        await prisma.$transaction(async (tx) => {
          await tx.user.update({
            where: { id: userId },
            data: {
              downloadsThisMonth: { increment: 1 },
            },
          });

          await tx.pattern.update({
            where: { id: patternId },
            data: {
              downloaded: true,
              downloadedAt: new Date(),
            },
          });
        });
      }

      const fileName = `${(pattern.patternData as any).patternName.replace(/[^a-z0-9]/gi, '_')}.pdf`;

      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      res.setHeader('Content-Length', pdfBuffer.length);

      res.send(pdfBuffer);
    } catch (error) {
      console.error('Download pattern error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to download pattern. Please try again.',
      });
    }
  }

  // GET /api/patterns/list - Get all available patterns with metadata
  async listPatterns(req: Request, res: Response) {
    try {
      const allPatterns = getAllPatterns()
        .filter((patternDef) => {
          if (process.env.NODE_ENV !== 'production') {
            return true;
          }
          return patternDef.enabled !== false;
        })
        .map((patternDef) => {
          const quiltPattern = getQuiltPattern(patternDef.id);
          return {
            id: patternDef.id,
            name: patternDef.name,
            skillLevel: quiltPattern?.skillLevel || 'intermediate',
            description: quiltPattern?.description || '',
            recommendedFabricCount: quiltPattern?.recommendedFabricCount || null,
            minColors: patternDef.minFabrics,
            maxFabrics: patternDef.maxFabrics,
            allowRotation: patternDef.allowRotation ?? true,
          };
        });

      res.json({
        success: true,
        data: allPatterns,
      });
    } catch (error) {
      console.error('List patterns error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to list patterns',
      });
    }
  }

  // GET /api/patterns/:id/fabric-roles - Get pattern-specific fabric role labels
  async getFabricRoles(req: Request, res: Response) {
    try {
      const patternId = normalizePatternId(req.params.id);

      if (patternId === 'auto') {
        return res.status(400).json({
          success: false,
          message: 'Cannot get fabric roles for auto pattern selection',
        });
      }

      const patterns = getAllPatterns();
      const pattern = patterns.find((p) => p.id === patternId);

      if (!pattern) {
        return res.status(404).json({
          success: false,
          message: 'Pattern not found',
        });
      }

      const defaultRoles = ['Background', 'Primary', 'Secondary', 'Accent', 'Contrast', 'Highlight', 'Border', 'Binding'];

      const fabricRoles = pattern.fabricRoles || defaultRoles.slice(0, pattern.maxFabrics);

      res.json({
        success: true,
        data: {
          patternId: pattern.id,
          patternName: pattern.name,
          fabricRoles: fabricRoles,
          minFabrics: pattern.minFabrics,
          maxFabrics: pattern.maxFabrics,
        },
      });
    } catch (error) {
      console.error('Get fabric roles error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get fabric roles',
      });
    }
  }
}
